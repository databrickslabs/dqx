# Quality rules

This page provides a reference for the quality rule functions (checks) available in DQX.

## Row-level quality rule functions (checks)

The following row-level checks are currently available in DQX.
These checks are applied to each row of a PySpark DataFrame and generate issue reports as additional columns.
You can also define own checks (see [Creating custom checks](#creating-custom-checks)).

| Check                            | Description                                                                                                                                                                                                                        | Arguments                                                                                                                                                                                    |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| is_not_null                      | Checks whether the values in the input column are not null.                                                                                                                                                                        | col_name: column name to check                                                                                                                                                               |
| is_not_empty                     | Checks whether the values in the input column are not empty (but may be null).                                                                                                                                                     | col_name: column name to check                                                                                                                                                               |
| is_not_null_and_not_empty        | Checks whether the values in the input column are not null and not empty.                                                                                                                                                          | col_name: column name to check; trim_strings: boolean flag to trim spaces from strings                                                                                                       |
| value_is_in_list                 | Checks whether the values in the input column are present in the list of allowed values (null values are allowed).                                                                                                                 | col_name: column name to check; allowed: list of allowed values                                                                                                                              |
| value_is_not_null_and_is_in_list | Checks whether the values in the input column are not null and present in the list of allowed values.                                                                                                                              | col_name: column name to check; allowed: list of allowed values                                                                                                                              |
| is_not_null_and_not_empty_array  | Checks whether the values in the array input column are not null and not empty.                                                                                                                                                    | col_name: column name to check                                                                                                                                                               |
| is_in_range                      | Checks whether the values in the input column are in the provided limits (inclusive of both boundaries) as number, date, timestamp, column name or expression.                                                                     | col_name: column name to check; min_limit: min limit value; max_limit: max limit value; min_limit_col_expr: min limit column name or expr; max_limit_col_expr: max limit column name or expr |
| is_not_in_range                  | Checks whether the values in the input column are outside the provided limits (exclusive of both boundaries) as number, date, timestamp, column name or expression.                                                                | col_name: column name to check; min_limit: min limit value; max_limit: max limit value; min_limit_col_expr: min limit column name or expr; max_limit_col_expr: max limit column name or expr |
| not_less_than                    | Checks whether the values in the input column are not less than the provided limit as number, date, timestamp, column name or expression.                                                                                          | col_name: column name to check; limit: limit value; limit_col_expr: min limit column name or expr                                                                                            |
| not_greater_than                 | Checks whether the values in the input column are not greater than the provided limit as number, date, timestamp, column name or expression.                                                                                       | col_name: column name to check; limit: limit value; limit_col_expr: min limit column name or expr                                                                                            |
| is_valid_date                    | Checks whether the values in the input column have valid date formats.                                                                                                                                                             | col_name: column name to check; date_format: date format (e.g. 'yyyy-mm-dd')                                                                                                                 |
| is_valid_timestamp               | Checks whether the values in the input column have valid timestamp formats.                                                                                                                                                        | col_name: column name to check; timestamp_format: timestamp format (e.g. 'yyyy-mm-dd HH:mm:ss')                                                                                              |
| not_in_future                    | Checks whether the values in the input column contain a timestamp that is not in the future, where 'future' is defined as current_timestamp + offset (in seconds).                                                                 | col_name: column name to check; offset: offset to use; curr_timestamp: current timestamp, if not provided current_timestamp() function is used                                               |
| not_in_near_future               | Checks whether the values in the input column contain a timestamp that is not in the near future, where 'near future' is defined as greater than the current timestamp but less than the current_timestamp + offset (in seconds).  | col_name: column name to check; offset: offset to use; curr_timestamp: current timestamp, if not provided current_timestamp() function is used                                               |
| is_older_than_n_days             | Checks whether the values in one input column are at least N days older than the values in another column.                                                                                                                         | col_name: column name to check; days: number of days; curr_date: current date, if not provided current_date() function is used                                                               |
| is_older_than_col2_for_n_days    | Checks whether the values in one input column are at least N days older than the values in another column.                                                                                                                         | col_name1: first column name to check; col_name2: second column name to check; days: number of days                                                                                          |
| regex_match                      | Checks whether the values in the input column matches a given regex.                                                                                                                                                               | col_name: column name to check; regex: regex to check; negate: if the condition should be negated (true) or not                                                                              |
| sql_expression                   | Checks whether the condition provided as an SQL expression is met, eg. a = 'str1', a > b                                                                                                                                           | expression: sql expression to check; msg: optional message to output; name: optional name of the resulting column; negate: if the condition should be negated                                |
| is_unique                        | Checks whether the values in the input column are unique and reports an issue for each row that contains a duplicate value. Null values are not considered duplicates, following the ANSI SQL standard.                            | col_name: column name to check                                                                                                                                                               |

You can check implementation details of the rules [here](https://github.com/databrickslabs/dqx/blob/main/src/databricks/labs/dqx/col_functions.py).

### Usage examples

Below are examples of how to use each check in YAML format and with DQX classes. Both are equivalent and can be used interchangeably.

The `criticality` field can be either "error" (data goes only into the 'bad' or 'quarantine' DataFrame) or "warn" (data goes into both DataFrames).
For brevity, the `name` field in the examples is omitted, meaning it will be auto-generated in the results.

#### Checks defined as yaml

```yaml
# is_not_null check
- criticality: error
  check:
    function: is_not_null
    arguments:
      col_name: col1

# is_not_empty check
- criticality: error
  check:
    function: is_not_empty
    arguments:
      col_name: col1

# is_not_null_and_not_empty check
- criticality: error
  check:
    function: is_not_null_and_not_empty
    arguments:
      col_name: col1
- criticality: error
  check:
    function: is_not_null_and_not_empty
    arguments:
      col_name: col2
      trim_strings: true

# value_is_in_list check
- criticality: error
  check:
    function: value_is_in_list
    arguments:
      col_name: col1
      allowed:
      - 1
      - 2

# value_is_not_null_and_is_in_list check
- criticality: error
  check:
    function: value_is_not_null_and_is_in_list
    arguments:
      col_name: col1
      allowed:
      - 1
      - 2

# is_not_null_and_not_empty_array check
- criticality: error
  check:
    function: is_not_null_and_not_empty_array
    arguments:
      col_name: col2

# is_in_range check
- criticality: error
  check:
    function: is_in_range
    arguments:
      col_name: col2
      min_limit: 1
      max_limit: 10
- criticality: error
  check:
    function: is_in_range
    arguments:
      col_name: col3
      min_limit: 2025-01-01
      max_limit: 2025-02-24
- criticality: error
  check:
    function: is_in_range
    arguments:
      col_name: col4
      min_limit: 2025-01-01 00:00:00
      max_limit: 2025-02-24 01:00:00
- criticality: error
  check:
    function: is_in_range
    arguments:
      col_name: col4
      min_limit_col_expr: col1
      max_limit_col_expr: col2 * 2

# is_not_in_range check
- criticality: error
  check:
    function: is_not_in_range
    arguments:
      col_name: col2
      min_limit: 1
      max_limit: 10
- criticality: error
  check:
    function: is_not_in_range
    arguments:
      col_name: col3
      min_limit: 2025-01-01
      max_limit: 2025-02-24
- criticality: error
  check:
    function: is_not_in_range
    arguments:
      col_name: col4
      min_limit: 2025-01-01 00:00:00
      max_limit: 2025-02-24 01:00:00
- criticality: error
  check:
    function: is_not_in_range
    arguments:
      col_name: col4
      min_limit_col_expr: col1
      max_limit_col_expr: col2 * 2

# not_less_than check
- criticality: error
  check:
    function: not_less_than
    arguments:
      col_name: col1
      limit: 0
- criticality: error
  check:
    function: not_less_than
    arguments:
      col_name: col3
      limit: 2025-01-01
- criticality: error
  check:
    function: not_less_than
    arguments:
      col_name: col4
      limit: 2025-02-24 01:00:00
- criticality: error
  check:
    function: not_less_than
    arguments:
      col_name: col1
      limit_col_expr: col1 * 2
      limit: 0  # ignored when limit_col_expr is provided

# not_greater_than check
- criticality: error
  check:
    function: not_greater_than
    arguments:
      col_name: col1
      limit: 10
- criticality: error
  check:
    function: not_greater_than
    arguments:
      col_name: col3
      limit: 2025-03-01
- criticality: error
  check:
    function: not_greater_than
    arguments:
      col_name: col4
      limit: 2025-03-24 01:00:00
- criticality: error
  check:
    function: not_greater_than
    arguments:
      col_name: col2
      limit_col_expr: col1 * 2
      limit: 0  # ignored when limit_col_expr is provided

# is_valid_date check
- criticality: error
  check:
    function: is_valid_date
    arguments:
      col_name: col3
- criticality: error
  check:
    function: is_valid_date
    arguments:
      col_name: col3
      date_format: yyyy-MM-dd

# is_valid_timestamp check
- criticality: error
  check:
    function: is_valid_timestamp
    arguments:
      col_name: col4
- criticality: error
  check:
    function: is_valid_timestamp
    arguments:
      col_name: col4
      timestamp_format: yyyy-MM-dd HH:mm:ss

# not_in_future check
- criticality: error
  check:
    function: not_in_future
    arguments:
      col_name: col4
      offset: 86400

# not_in_near_future check
- criticality: error
  check:
    function: not_in_near_future
    arguments:
      col_name: col4
      offset: 36400

# is_older_than_n_days check
- criticality: error
  check:
    function: is_older_than_n_days
    arguments:
      col_name: col3
      days: 2

# is_older_than_col2_for_n_days check
- criticality: error
  check:
    function: is_older_than_col2_for_n_days
    arguments:
      col_name1: col3
      col_name2: col5
      days: 2

# regex_match check
- criticality: error
  check:
    function: regex_match
    arguments:
      col_name: col1
      regex: '[0-9]+'
- criticality: error
  check:
    function: regex_match
    arguments:
      col_name: col2
      regex: '[0-9]+'
      negate: true

# sql_expression check
- criticality: error
  check:
    function: sql_expression
    arguments:
      expression: col1 > col2 and col3 < 10
      msg: col1 is greater than col2 and col3 less than 10
      name: custom_output_name
- criticality: error
  check:
    function: sql_expression
    arguments:
      expression: col1 < col2
      msg: col1 is less than col2
      negate: true

# is_unique check
- criticality: error
  check:
    function: is_unique
    arguments:
      col_name: col1
```

#### Checks defined with DQX classes

```python
from databricks.labs.dqx.col_functions import *

checks = [
    DQRule(
        criticality="error",
        check=is_not_null("col1")
    ),
    DQRule(
        criticality="error",
        check=is_not_empty("col1")
    ),
    DQRule(
        criticality="error",
        check=is_not_null_and_not_empty("col1")
    ),
    DQRule(
        criticality="error",
        check=is_not_null_and_not_empty("col2", trim_strings=True)
    ),
    DQRule(
        criticality="error",
        check=value_is_in_list("col1", [1, 2])
    ),
    DQRule(
        criticality="error",
        check=value_is_not_null_and_is_in_list("col1", [1, 2])
    ),
    DQRule(
        criticality="error",
        check=is_not_null_and_not_empty_array("col2")
    ),
    DQRule(
        criticality="error",
        check=is_in_range("col2", min_limit=1, max_limit=10)
    ),
    DQRule(
        criticality="error",
        check=is_in_range("col3", min_limit="2025-01-01", max_limit="2025-02-24")
    ),
    DQRule(
        criticality="error",
        check=is_in_range("col4", min_limit="2025-01-01 00:00:00", max_limit="2025-02-24 01:00:00")
    ),
    DQRule(
        criticality="error",
        check=is_in_range("col4", min_limit_col_expr="col1", max_limit_col_expr="col2 * 2")
    ),
    DQRule(
        criticality="error",
        check=is_not_in_range("col2", min_limit=1, max_limit=10)
    ),
    DQRule(
        criticality="error",
        check=is_not_in_range("col3", min_limit="2025-01-01", max_limit="2025-02-24")
    ),
    DQRule(
        criticality="error",
        check=is_not_in_range("col4", min_limit="2025-01-01 00:00:00", max_limit="2025-02-24 01:00:00")
    ),
    DQRule(
        criticality="error",
        check=is_not_in_range("col4", min_limit_col_expr="col1", max_limit_col_expr="col2 * 2")
    ),
    DQRule(
        criticality="error",
        check=not_less_than("col1", limit=0)
    ),
    DQRule(
        criticality="error",
        check=not_less_than("col3", limit="2025-01-01")
    ),
    DQRule(
        criticality="error",
        check=not_less_than("col4", limit="2025-02-24 01:00:00")
    ),
    DQRule(
        criticality="error",
        check=not_less_than("col1", limit_col_expr="col1 * 2", limit=0)
    ),
    DQRule(
        criticality="error",
        check=not_greater_than("col1", limit=10)
    ),
    DQRule(
        criticality="error",
        check=not_greater_than("col3", limit="2025-03-01")
    ),
    DQRule(
        criticality="error",
        check=not_greater_than("col4", limit="2025-03-24 01:00:00")
    ),
    DQRule(
        criticality="error",
        check=not_greater_than("col2", limit_col_expr="col1 * 2", limit=0)
    ),
    DQRule(
        criticality="error",
        check=is_valid_date("col3")
    ),
    DQRule(
        criticality="error",
        check=is_valid_date("col3", date_format="yyyy-MM-dd")
    ),
    DQRule(
        criticality="error",
        check=is_valid_timestamp("col4")
    ),
    DQRule(
        criticality="error",
        check=is_valid_timestamp("col4", timestamp_format="yyyy-MM-dd HH:mm:ss")
    ),
    DQRule(
        criticality="error",
        check=not_in_future("col4", offset=86400)
    ),
    DQRule(
        criticality="error",
        check=not_in_near_future("col4", offset=36400)
    ),
    DQRule(
        criticality="error",
        check=is_older_than_n_days("col3", days=2)
    ),
    DQRule(
        criticality="error",
        check=is_older_than_col2_for_n_days("col3", "col5", days=2)
    ),
    DQRule(
        criticality="error",
        check=regex_match("col1", regex="[0-9]+")
    ),
    DQRule(
        criticality="error",
        check=regex_match("col2", regex="[0-9]+", negate=True)
    ),
    DQRule(
        criticality="error",
        check=sql_expression(expression="col1 > col2 and col3 < 10", msg="col1 is greater than col2 and col3 less than 10", name="custom_output_name")
    ),
    DQRule(
        criticality="error",
        check=sql_expression(expression="col1 < col2", msg="col1 is less than col2", negate=True)
    ),
    DQRule(
        criticality="error",
        check=is_unique("col1")
    )
]
```

## Applying filters on checks

You can apply checks to a part of the DataFrame by using a `filter`.
For example, to ensure that a column `a` is not null only when a column `b` is positive, you can define the check as follows:
```yaml
- criticality: error
  filter: b > 0
  check:
    function: is_not_null
    arguments:
      col_name: a
```

## Creating custom checks

### Use sql expression

If a check that you need does not exist in DQX, you can define them using sql expression rule (`sql_expression`),
for example:
```yaml
- criticality: error
  check:
    function: sql_expression
    arguments:
      expression: col1 LIKE '%foo'
      msg: col1 ends with 'foo'
```

Sql expression is also useful if you want to make cross-column validation, for example:
```yaml
- criticality: error
  check:
    function: sql_expression
    arguments:
      expression: a > b
      msg: a is greater than b
```

### Define custom checks as python function

If you need a reusable check or need to implement a more complicated logic
you can define your own check functions. A check is a function available from 'globals' that returns `pyspark.sql.Column`, for example:

```python
import pyspark.sql.functions as F
from pyspark.sql import Column
from databricks.labs.dqx.col_functions import make_condition

def ends_with_foo(col_name: str) -> Column:
    column = F.col(col_name)
    return make_condition(column.endswith("foo"), f"Column {col_name} ends with foo", f"{col_name}_ends_with_foo")
```

and use the function as a check:
```python
import yaml
from databricks.labs.dqx.engine import DQEngine
from databricks.sdk import WorkspaceClient
from databricks.labs.dqx.col_functions import *

checks = yaml.safe_load("""
- criticality: error
  check:
    function: ends_with_foo
    arguments:
      col_name: col1
""")

dq_engine = DQEngine(WorkspaceClient())

# Option 1: apply quality rules on the dataframe and provide valid and invalid (quarantined) dataframes 
valid_df, quarantined_df = dq_engine.apply_checks_by_metadata_and_split(input_df, checks, globals())

# Option 2: apply quality rules on the dataframe and report issues as additional columns (`_warning` and `_error`)
valid_and_quarantined_df = dq_engine.apply_checks_by_metadata(input_df, checks, globals())
```

You can see all existing DQX checks [here](https://github.com/databrickslabs/dqx/blob/main/src/databricks/labs/dqx/col_functions.py). 

Feel free to submit a PR to DQX with your own check so that other can benefit from it (see [contribution guide](/docs/dev/contributing)).
