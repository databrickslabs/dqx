/**
 * Generated by orval v8.0.0-rc.0 üç∫
 * Do not edit manually.
 * dqx
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import * as axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";

export type ChecksInChecksItem = { [key: string]: unknown };

export interface ChecksIn {
  checks: ChecksInChecksItem[];
}

export type ChecksOutChecksItem = { [key: string]: unknown };

export interface ChecksOut {
  checks: ChecksOutChecksItem[];
}

export type ComplexValueDisplay = string | null;

export type ComplexValuePrimary = boolean | null;

export type ComplexValueRef = string | null;

export type ComplexValueType = string | null;

export type ComplexValueValue = string | null;

export interface ComplexValue {
  display?: ComplexValueDisplay;
  primary?: ComplexValuePrimary;
  ref?: ComplexValueRef;
  type?: ComplexValueType;
  value?: ComplexValueValue;
}

export interface ConfigIn {
  config: WorkspaceConfigInput;
}

export interface ConfigOut {
  config: WorkspaceConfigOutput;
}

export type ExtraParamsResultColumnNames = { [key: string]: string };

export type ExtraParamsUserMetadata = { [key: string]: string };

export type ExtraParamsRunTimeOverwrite = string | null;

export type ExtraParamsRunIdOverwrite = string | null;

export interface ExtraParams {
  result_column_names?: ExtraParamsResultColumnNames;
  user_metadata?: ExtraParamsUserMetadata;
  run_time_overwrite?: ExtraParamsRunTimeOverwrite;
  run_id_overwrite?: ExtraParamsRunIdOverwrite;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type InputConfigSchema = string | null;

export type InputConfigOptions = { [key: string]: string };

export interface InputConfig {
  location: string;
  format?: string;
  is_streaming?: boolean;
  schema?: InputConfigSchema;
  options?: InputConfigOptions;
}

export interface InstallationSettings {
  /** Path to the folder containing config.yml */
  install_folder: string;
}

export interface LLMConfig {
  model?: LLMModelConfig;
}

export interface LLMModelConfig {
  model_name?: string;
  api_key?: string;
  api_base?: string;
}

export type NameFamilyName = string | null;

export type NameGivenName = string | null;

export interface Name {
  family_name?: NameFamilyName;
  given_name?: NameGivenName;
}

export type OutputConfigOptions = { [key: string]: string };

export type OutputConfigTrigger = { [key: string]: string | boolean };

export interface OutputConfig {
  location: string;
  format?: string;
  mode?: string;
  options?: OutputConfigOptions;
  trigger?: OutputConfigTrigger;
}

export type ProfilerConfigSampleSeed = number | null;

export type ProfilerConfigFilter = string | null;

export interface ProfilerConfig {
  summary_stats_file?: string;
  sample_fraction?: number;
  sample_seed?: ProfilerConfigSampleSeed;
  limit?: number;
  filter?: ProfilerConfigFilter;
  llm_primary_key_detection?: boolean;
}

export type RunConfigInputConfig = InputConfig | null;

export type RunConfigOutputConfig = OutputConfig | null;

export type RunConfigQuarantineConfig = OutputConfig | null;

export type RunConfigMetricsConfig = OutputConfig | null;

export type RunConfigChecksUserRequirements = string | null;

export type RunConfigWarehouseId = string | null;

export type RunConfigReferenceTables = { [key: string]: InputConfig };

export type RunConfigCustomCheckFunctions = { [key: string]: string };

export type RunConfigLakebaseInstanceName = string | null;

export type RunConfigLakebaseClientId = string | null;

export type RunConfigLakebasePort = string | null;

export interface RunConfig {
  name?: string;
  input_config?: RunConfigInputConfig;
  output_config?: RunConfigOutputConfig;
  quarantine_config?: RunConfigQuarantineConfig;
  metrics_config?: RunConfigMetricsConfig;
  profiler_config?: ProfilerConfig;
  checks_user_requirements?: RunConfigChecksUserRequirements;
  checks_location?: string;
  warehouse_id?: RunConfigWarehouseId;
  reference_tables?: RunConfigReferenceTables;
  custom_check_functions?: RunConfigCustomCheckFunctions;
  lakebase_instance_name?: RunConfigLakebaseInstanceName;
  lakebase_client_id?: RunConfigLakebaseClientId;
  lakebase_port?: RunConfigLakebasePort;
}

export interface RunConfigIn {
  config: RunConfig;
}

export interface RunConfigOut {
  config: RunConfig;
}

export type UserActive = boolean | null;

export type UserDisplayName = string | null;

export type UserEmails = ComplexValue[] | null;

export type UserEntitlements = ComplexValue[] | null;

export type UserExternalId = string | null;

export type UserGroups = ComplexValue[] | null;

export type UserId = string | null;

export type UserName = Name | null;

export type UserRoles = ComplexValue[] | null;

export type UserSchemas = UserSchema[] | null;

export type UserUserName = string | null;

export interface User {
  active?: UserActive;
  display_name?: UserDisplayName;
  emails?: UserEmails;
  entitlements?: UserEntitlements;
  external_id?: UserExternalId;
  groups?: UserGroups;
  id?: UserId;
  name?: UserName;
  roles?: UserRoles;
  schemas?: UserSchemas;
  user_name?: UserUserName;
}

export type UserSchema = (typeof UserSchema)[keyof typeof UserSchema];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSchema = {
  "urn:ietf:params:scim:schemas:core:20:User":
    "urn:ietf:params:scim:schemas:core:2.0:User",
  "urn:ietf:params:scim:schemas:extension:workspace:20:User":
    "urn:ietf:params:scim:schemas:extension:workspace:2.0:User",
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface VersionOut {
  version: string;
}

export type WorkspaceConfigInputLogLevel = string | null;

export type WorkspaceConfigInputExtraParams = ExtraParams | null;

export type WorkspaceConfigInputProfilerOverrideClustersAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigInputProfilerOverrideClusters =
  WorkspaceConfigInputProfilerOverrideClustersAnyOf | null;

export type WorkspaceConfigInputQualityCheckerOverrideClustersAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigInputQualityCheckerOverrideClusters =
  WorkspaceConfigInputQualityCheckerOverrideClustersAnyOf | null;

export type WorkspaceConfigInputE2eOverrideClustersAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigInputE2eOverrideClusters =
  WorkspaceConfigInputE2eOverrideClustersAnyOf | null;

export type WorkspaceConfigInputProfilerSparkConfAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigInputProfilerSparkConf =
  WorkspaceConfigInputProfilerSparkConfAnyOf | null;

export type WorkspaceConfigInputQualityCheckerSparkConfAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigInputQualityCheckerSparkConf =
  WorkspaceConfigInputQualityCheckerSparkConfAnyOf | null;

export type WorkspaceConfigInputE2eSparkConfAnyOf = { [key: string]: string };

export type WorkspaceConfigInputE2eSparkConf =
  WorkspaceConfigInputE2eSparkConfAnyOf | null;

export type WorkspaceConfigInputCustomMetrics = string[] | null;

export interface WorkspaceConfigInput {
  run_configs: RunConfig[];
  log_level?: WorkspaceConfigInputLogLevel;
  serverless_clusters?: boolean;
  upload_dependencies?: boolean;
  extra_params?: WorkspaceConfigInputExtraParams;
  profiler_override_clusters?: WorkspaceConfigInputProfilerOverrideClusters;
  quality_checker_override_clusters?: WorkspaceConfigInputQualityCheckerOverrideClusters;
  e2e_override_clusters?: WorkspaceConfigInputE2eOverrideClusters;
  profiler_spark_conf?: WorkspaceConfigInputProfilerSparkConf;
  quality_checker_spark_conf?: WorkspaceConfigInputQualityCheckerSparkConf;
  e2e_spark_conf?: WorkspaceConfigInputE2eSparkConf;
  profiler_max_parallelism?: number;
  quality_checker_max_parallelism?: number;
  custom_metrics?: WorkspaceConfigInputCustomMetrics;
  llm_config?: LLMConfig;
}

export type WorkspaceConfigOutputLogLevel = string | null;

export type WorkspaceConfigOutputExtraParams = ExtraParams | null;

export type WorkspaceConfigOutputProfilerOverrideClustersAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigOutputProfilerOverrideClusters =
  WorkspaceConfigOutputProfilerOverrideClustersAnyOf | null;

export type WorkspaceConfigOutputQualityCheckerOverrideClustersAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigOutputQualityCheckerOverrideClusters =
  WorkspaceConfigOutputQualityCheckerOverrideClustersAnyOf | null;

export type WorkspaceConfigOutputE2eOverrideClustersAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigOutputE2eOverrideClusters =
  WorkspaceConfigOutputE2eOverrideClustersAnyOf | null;

export type WorkspaceConfigOutputProfilerSparkConfAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigOutputProfilerSparkConf =
  WorkspaceConfigOutputProfilerSparkConfAnyOf | null;

export type WorkspaceConfigOutputQualityCheckerSparkConfAnyOf = {
  [key: string]: string;
};

export type WorkspaceConfigOutputQualityCheckerSparkConf =
  WorkspaceConfigOutputQualityCheckerSparkConfAnyOf | null;

export type WorkspaceConfigOutputE2eSparkConfAnyOf = { [key: string]: string };

export type WorkspaceConfigOutputE2eSparkConf =
  WorkspaceConfigOutputE2eSparkConfAnyOf | null;

export type WorkspaceConfigOutputCustomMetrics = string[] | null;

export interface WorkspaceConfigOutput {
  run_configs: RunConfig[];
  log_level?: WorkspaceConfigOutputLogLevel;
  serverless_clusters?: boolean;
  upload_dependencies?: boolean;
  extra_params?: WorkspaceConfigOutputExtraParams;
  profiler_override_clusters?: WorkspaceConfigOutputProfilerOverrideClusters;
  quality_checker_override_clusters?: WorkspaceConfigOutputQualityCheckerOverrideClusters;
  e2e_override_clusters?: WorkspaceConfigOutputE2eOverrideClusters;
  profiler_spark_conf?: WorkspaceConfigOutputProfilerSparkConf;
  quality_checker_spark_conf?: WorkspaceConfigOutputQualityCheckerSparkConf;
  e2e_spark_conf?: WorkspaceConfigOutputE2eSparkConf;
  profiler_max_parallelism?: number;
  quality_checker_max_parallelism?: number;
  custom_metrics?: WorkspaceConfigOutputCustomMetrics;
  llm_config?: LLMConfig;
}

export type ConfigParams = {
  /**
   * Path to the configuration folder
   */
  path?: string | null;
};

export type SaveConfigParams = {
  /**
   * Path to the configuration folder
   */
  path?: string | null;
};

export type GetRunConfigParams = {
  /**
   * Path to the configuration folder
   */
  path?: string | null;
};

export type DeleteRunConfigParams = {
  /**
   * Path to the configuration folder
   */
  path?: string | null;
};

export type SaveRunConfigParams = {
  /**
   * Path to the configuration folder
   */
  path?: string | null;
};

export type GetRunChecksParams = {
  /**
   * Path to the configuration folder
   */
  path?: string | null;
};

export type SaveRunChecksParams = {
  /**
   * Path to the configuration folder
   */
  path?: string | null;
};

/**
 * @summary Version
 */
export const version = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VersionOut>> => {
  return axios.default.get(`/api/version`, options);
};

export const getVersionQueryKey = () => {
  return [`/api/version`] as const;
};

export const getVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionQueryError = AxiosError<unknown>;

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVersionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionSuspenseQueryError = AxiosError<unknown>;

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Me
 */
export const currentUser = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<User>> => {
  return axios.default.get(`/api/current-user`, options);
};

export const getCurrentUserQueryKey = () => {
  return [`/api/current-user`] as const;
};

export const getCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUser>>> = ({
    signal,
  }) => currentUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof currentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof currentUser>>
>;
export type CurrentUserQueryError = AxiosError<HTTPValidationError>;

export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUser>>,
          TError,
          Awaited<ReturnType<typeof currentUser>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUser>>,
          TError,
          Awaited<ReturnType<typeof currentUser>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Me
 */

export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCurrentUserQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCurrentUserSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof currentUser>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUser>>> = ({
    signal,
  }) => currentUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof currentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CurrentUserSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof currentUser>>
>;
export type CurrentUserSuspenseQueryError = AxiosError<HTTPValidationError>;

export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Me
 */

export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCurrentUserSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Settings
 */
export const getSettings = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<InstallationSettings>> => {
  return axios.default.get(`/api/settings`, options);
};

export const getGetSettingsQueryKey = () => {
  return [`/api/settings`] as const;
};

export const getGetSettingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSettingsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSettings>>> = ({
    signal,
  }) => getSettings({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSettings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSettingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSettings>>
>;
export type GetSettingsQueryError = AxiosError<HTTPValidationError>;

export function useGetSettings<
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSettings>>,
          TError,
          Awaited<ReturnType<typeof getSettings>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSettings<
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSettings>>,
          TError,
          Awaited<ReturnType<typeof getSettings>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSettings<
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Settings
 */

export function useGetSettings<
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSettings>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSettingsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSettingsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getSettings>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSettingsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSettings>>> = ({
    signal,
  }) => getSettings({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSettings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSettingsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSettings>>
>;
export type GetSettingsSuspenseQueryError = AxiosError<HTTPValidationError>;

export function useGetSettingsSuspense<
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSettings>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSettingsSuspense<
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSettings>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSettingsSuspense<
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSettings>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Settings
 */

export function useGetSettingsSuspense<
  TData = Awaited<ReturnType<typeof getSettings>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSettings>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSettingsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Save Settings
 */
export const saveSettings = (
  installationSettings: InstallationSettings,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<InstallationSettings>> => {
  return axios.default.post(`/api/settings`, installationSettings, options);
};

export const getSaveSettingsMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveSettings>>,
    TError,
    { data: InstallationSettings },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveSettings>>,
  TError,
  { data: InstallationSettings },
  TContext
> => {
  const mutationKey = ["saveSettings"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveSettings>>,
    { data: InstallationSettings }
  > = (props) => {
    const { data } = props ?? {};

    return saveSettings(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveSettingsMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveSettings>>
>;
export type SaveSettingsMutationBody = InstallationSettings;
export type SaveSettingsMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Save Settings
 */
export const useSaveSettings = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveSettings>>,
      TError,
      { data: InstallationSettings },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveSettings>>,
  TError,
  { data: InstallationSettings },
  TContext
> => {
  const mutationOptions = getSaveSettingsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Config
 */
export const config = (
  params?: ConfigParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ConfigOut>> => {
  return axios.default.get(`/api/config`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getConfigQueryKey = (params?: ConfigParams) => {
  return [`/api/config`, ...(params ? [params] : [])] as const;
};

export const getConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: ConfigParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getConfigQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof config>>> = ({
    signal,
  }) => config(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof config>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConfigQueryResult = NonNullable<Awaited<ReturnType<typeof config>>>;
export type ConfigQueryError = AxiosError<HTTPValidationError>;

export function useConfig<
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: undefined | ConfigParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof config>>,
          TError,
          Awaited<ReturnType<typeof config>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useConfig<
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: ConfigParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof config>>,
          TError,
          Awaited<ReturnType<typeof config>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useConfig<
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: ConfigParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Config
 */

export function useConfig<
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: ConfigParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConfigQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getConfigSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: ConfigParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getConfigQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof config>>> = ({
    signal,
  }) => config(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof config>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConfigSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof config>>
>;
export type ConfigSuspenseQueryError = AxiosError<HTTPValidationError>;

export function useConfigSuspense<
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: undefined | ConfigParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useConfigSuspense<
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: ConfigParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useConfigSuspense<
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: ConfigParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Config
 */

export function useConfigSuspense<
  TData = Awaited<ReturnType<typeof config>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: ConfigParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof config>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConfigSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Save Config
 */
export const saveConfig = (
  configIn: ConfigIn,
  params?: SaveConfigParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ConfigOut>> => {
  return axios.default.post(`/api/config`, configIn, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getSaveConfigMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveConfig>>,
    TError,
    { data: ConfigIn; params?: SaveConfigParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveConfig>>,
  TError,
  { data: ConfigIn; params?: SaveConfigParams },
  TContext
> => {
  const mutationKey = ["saveConfig"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveConfig>>,
    { data: ConfigIn; params?: SaveConfigParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return saveConfig(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveConfig>>
>;
export type SaveConfigMutationBody = ConfigIn;
export type SaveConfigMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Save Config
 */
export const useSaveConfig = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveConfig>>,
      TError,
      { data: ConfigIn; params?: SaveConfigParams },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveConfig>>,
  TError,
  { data: ConfigIn; params?: SaveConfigParams },
  TContext
> => {
  const mutationOptions = getSaveConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Run Config
 */
export const getRunConfig = (
  name: string,
  params?: GetRunConfigParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RunConfigOut>> => {
  return axios.default.get(`/api/config/run/${name}`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetRunConfigQueryKey = (
  name?: string,
  params?: GetRunConfigParams,
) => {
  return [`/api/config/run/${name}`, ...(params ? [params] : [])] as const;
};

export const getGetRunConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunConfigParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunConfig>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRunConfigQueryKey(name, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunConfig>>> = ({
    signal,
  }) => getRunConfig(name, params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRunConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRunConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRunConfig>>
>;
export type GetRunConfigQueryError = AxiosError<HTTPValidationError>;

export function useGetRunConfig<
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params: undefined | GetRunConfigParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunConfig>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunConfig>>,
          TError,
          Awaited<ReturnType<typeof getRunConfig>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRunConfig<
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunConfigParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunConfig>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunConfig>>,
          TError,
          Awaited<ReturnType<typeof getRunConfig>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRunConfig<
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunConfigParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunConfig>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Run Config
 */

export function useGetRunConfig<
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunConfigParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunConfig>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRunConfigQueryOptions(name, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRunConfigSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunConfigParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunConfig>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRunConfigQueryKey(name, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunConfig>>> = ({
    signal,
  }) => getRunConfig(name, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getRunConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRunConfigSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRunConfig>>
>;
export type GetRunConfigSuspenseQueryError = AxiosError<HTTPValidationError>;

export function useGetRunConfigSuspense<
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params: undefined | GetRunConfigParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunConfig>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRunConfigSuspense<
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunConfigParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunConfig>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRunConfigSuspense<
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunConfigParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunConfig>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Run Config
 */

export function useGetRunConfigSuspense<
  TData = Awaited<ReturnType<typeof getRunConfig>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunConfigParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunConfig>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRunConfigSuspenseQueryOptions(
    name,
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Delete Run Config
 */
export const deleteRunConfig = (
  name: string,
  params?: DeleteRunConfigParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ConfigOut>> => {
  return axios.default.delete(`/api/config/run/${name}`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getDeleteRunConfigMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRunConfig>>,
    TError,
    { name: string; params?: DeleteRunConfigParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRunConfig>>,
  TError,
  { name: string; params?: DeleteRunConfigParams },
  TContext
> => {
  const mutationKey = ["deleteRunConfig"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRunConfig>>,
    { name: string; params?: DeleteRunConfigParams }
  > = (props) => {
    const { name, params } = props ?? {};

    return deleteRunConfig(name, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRunConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRunConfig>>
>;

export type DeleteRunConfigMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Delete Run Config
 */
export const useDeleteRunConfig = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRunConfig>>,
      TError,
      { name: string; params?: DeleteRunConfigParams },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRunConfig>>,
  TError,
  { name: string; params?: DeleteRunConfigParams },
  TContext
> => {
  const mutationOptions = getDeleteRunConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Save Run Config
 */
export const saveRunConfig = (
  runConfigIn: RunConfigIn,
  params?: SaveRunConfigParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RunConfigOut>> => {
  return axios.default.post(`/api/config/run`, runConfigIn, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getSaveRunConfigMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveRunConfig>>,
    TError,
    { data: RunConfigIn; params?: SaveRunConfigParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveRunConfig>>,
  TError,
  { data: RunConfigIn; params?: SaveRunConfigParams },
  TContext
> => {
  const mutationKey = ["saveRunConfig"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveRunConfig>>,
    { data: RunConfigIn; params?: SaveRunConfigParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return saveRunConfig(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveRunConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveRunConfig>>
>;
export type SaveRunConfigMutationBody = RunConfigIn;
export type SaveRunConfigMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Save Run Config
 */
export const useSaveRunConfig = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveRunConfig>>,
      TError,
      { data: RunConfigIn; params?: SaveRunConfigParams },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveRunConfig>>,
  TError,
  { data: RunConfigIn; params?: SaveRunConfigParams },
  TContext
> => {
  const mutationOptions = getSaveRunConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Run Checks
 */
export const getRunChecks = (
  name: string,
  params?: GetRunChecksParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ChecksOut>> => {
  return axios.default.get(`/api/config/run/${name}/checks`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetRunChecksQueryKey = (
  name?: string,
  params?: GetRunChecksParams,
) => {
  return [
    `/api/config/run/${name}/checks`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetRunChecksQueryOptions = <
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunChecksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunChecks>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRunChecksQueryKey(name, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunChecks>>> = ({
    signal,
  }) => getRunChecks(name, params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRunChecks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRunChecksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRunChecks>>
>;
export type GetRunChecksQueryError = AxiosError<HTTPValidationError>;

export function useGetRunChecks<
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params: undefined | GetRunChecksParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunChecks>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunChecks>>,
          TError,
          Awaited<ReturnType<typeof getRunChecks>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRunChecks<
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunChecksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunChecks>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRunChecks>>,
          TError,
          Awaited<ReturnType<typeof getRunChecks>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRunChecks<
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunChecksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunChecks>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Run Checks
 */

export function useGetRunChecks<
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunChecksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRunChecks>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRunChecksQueryOptions(name, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRunChecksSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunChecksParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunChecks>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRunChecksQueryKey(name, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRunChecks>>> = ({
    signal,
  }) => getRunChecks(name, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getRunChecks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRunChecksSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRunChecks>>
>;
export type GetRunChecksSuspenseQueryError = AxiosError<HTTPValidationError>;

export function useGetRunChecksSuspense<
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params: undefined | GetRunChecksParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunChecks>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRunChecksSuspense<
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunChecksParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunChecks>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRunChecksSuspense<
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunChecksParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunChecks>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Run Checks
 */

export function useGetRunChecksSuspense<
  TData = Awaited<ReturnType<typeof getRunChecks>>,
  TError = AxiosError<HTTPValidationError>,
>(
  name: string,
  params?: GetRunChecksParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRunChecks>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRunChecksSuspenseQueryOptions(
    name,
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Save Run Checks
 */
export const saveRunChecks = (
  name: string,
  checksIn: ChecksIn,
  params?: SaveRunChecksParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ChecksOut>> => {
  return axios.default.post(`/api/config/run/${name}/checks`, checksIn, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getSaveRunChecksMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveRunChecks>>,
    TError,
    { name: string; data: ChecksIn; params?: SaveRunChecksParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveRunChecks>>,
  TError,
  { name: string; data: ChecksIn; params?: SaveRunChecksParams },
  TContext
> => {
  const mutationKey = ["saveRunChecks"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveRunChecks>>,
    { name: string; data: ChecksIn; params?: SaveRunChecksParams }
  > = (props) => {
    const { name, data, params } = props ?? {};

    return saveRunChecks(name, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveRunChecksMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveRunChecks>>
>;
export type SaveRunChecksMutationBody = ChecksIn;
export type SaveRunChecksMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Save Run Checks
 */
export const useSaveRunChecks = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveRunChecks>>,
      TError,
      { name: string; data: ChecksIn; params?: SaveRunChecksParams },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveRunChecks>>,
  TError,
  { name: string; data: ChecksIn; params?: SaveRunChecksParams },
  TContext
> => {
  const mutationOptions = getSaveRunChecksMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
